<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <title>Shallow Water</title>
    <style>
            html, body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                width: 100%;
                height: 100%;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="info"></div>
    <script id="vs0" type="x-shader/vertex">
        attribute vec3 position;

        void main(){
            gl_Position = vec4(position, 1.0);
        }
    </script>
    <script id="vs1" type="x-shader/vertex">
            #define EPS 0.01
            #define STEPSIZE 0.01
            #define MAXSTEPS 1000
            #define FREQ 20.0
            #define AMP 0.005
            #define OVERSTEP 4.0
            #define AIR_IOR 1.0
            #define WATER_IOR 1.33
            #define FLOOR_WIDTH 2.0

            attribute vec3 position;

            uniform float time;
            uniform vec3 light1;
            uniform vec3 light2;
            uniform vec3 light3;

            varying vec3 start1;
            varying vec3 end1;
            varying vec3 start2;
            varying vec3 end2;
            varying vec3 start3;
            varying vec3 end3;

            float distBox(vec3 p)
            {
                vec3 b = vec3(1.0, 1.0, 1.0);
                vec3 d = abs(p) - b;
                return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
            }

            float sinusoid(float x, float z)
            {
                float t = x * x * sin(time) + z * z * sin(time);
                return AMP*(sin(FREQ*t) - cos((FREQ/2.0)*t));
            }

            float height(float x, float z)
            {
                vec2 uv = (vec2(x, z) + vec2(1.0)) * 0.5;
                return sinusoid(x, z);
                // return texture2D(heightSampler, uv).z;
            }

            vec3 getSurfaceNormal(vec3 p)
            {
                vec3 n = vec3(height(p.x - EPS, p.z) - height(p.x + EPS, p.z),
                              2.0 * EPS,
                              height(p.x, p.z - EPS) - height(p.x, p.z + EPS));
                return normalize(n);
            }

            vec3 getBoxNormal(vec3 p)
            {
                vec3 n = vec3((distBox(p+vec3(EPS,0,0))-distBox(p)),
                              (distBox(p+vec3(0,EPS,0))-distBox(p)),
                              (distBox(p+vec3(0,0,EPS))-distBox(p)));
                return normalize(n);
            }

            vec3 getRefractedDir(vec3 dir, vec3 n)
			{
				float costheta = dot(dir, -n);
				float ratio = AIR_IOR / WATER_IOR;
				float c = ratio * ratio * (1.0 - costheta * costheta);
				return ratio * dir + (ratio * costheta - sqrt(1.0 - c)) * n;
			}

            vec3 getEndPos(vec3 startPos, vec3 lightPos)
            {
                // Get the ray direction
                vec3 dir = normalize(startPos - lightPos);
                vec3 p = startPos;

                bool hitSurface = false;
                bool hitBox = false;

                for (int i = 0; i < 50; i++) {
                    float d = distBox(p);
                    if(d < EPS)
                    {
                        hitBox = true;
                        break;
                    }
                    p += dir * d;
                }

                if (!hitBox)
                {
                    return startPos;
                }
                
                // Approximate the surface point using the plane y = 0
                float t = -p.y/dir.y;
                p = p + t*dir;
                hitSurface = true;

                // Checks if point is outside of surface region
                /*
                if (max(p.x, p.z) > 1.0 || min(p.x, p.z) < -1.0)
                {
                    return p;
                }
                */

                // Calculate the intersection with the floor directly
                dir = normalize(getRefractedDir(dir, getSurfaceNormal(p)));
                t = (-1.0-p.y)/dir.y;
                p = p + t*dir;

                return p; 
            }

            vec3 remapCoordinate(vec3 pos, vec3 lightPos)
            {
                vec3 dir = normalize(pos - lightPos);
                // Assuming a plane with equation y = 1.5
                float t = (1.5-lightPos.y)/dir.y;
                return lightPos + t*dir;
            }

            void main() {
                gl_Position = vec4( position, 1.0 );
                vec3 worldSpacePos = position.xzy;

                start3 = remapCoordinate(worldSpacePos, light3);
                end3 = getEndPos(start3, light3).xzy;
                start3 = start3.xzy;
            }
    </script>
    <script id="fs0" type="x-shader/fragment">
            #define EPS 0.001
            #define STEPSIZE 0.001
            #define MAXSTEPS 1000
            #define FREQ 20.0
            #define AMP 0.005
            #define OVERSTEP 4.0
            #define AIR_IOR 1.0
            #define WATER_IOR 1.33
            #define TANK_HEIGHT 0.5
            #define BBOX_HEIGHT 0.02
            #define FLOOR_WIDTH 2.0

            uniform float time;
            uniform vec2 resolution;
            uniform sampler2D heightSampler;
            uniform sampler2D wallSampler;
            uniform sampler2D skySampler;
            uniform sampler2D causticsSampler;
            uniform vec3 eyeCoordinate;

            uniform vec3 light1;
            uniform vec3 light2;
            uniform vec3 light3;

            float distBox(vec3 p, vec3 b)
            {
                vec3 d = abs(p) - b;
                return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
            }
            
            float distBox(vec3 p)
            {
                return distBox(p, vec3(1.0, TANK_HEIGHT, 1.0));
            }
            
            float distWaveBbox(vec3 p)
            {
                return distBox(p, vec3(1.0, BBOX_HEIGHT, 1.0));
            }
            
            float sinusoid(float x, float z)
            {
                float t = x * x * sin(time) + z * z * sin(time);
                return AMP*(sin(FREQ*t) - cos((FREQ/2.0)*t));
            }
            
            float height(float x, float z)
            {
                vec2 uv = (vec2(x, z) + vec2(1.0)) * 0.5;
                return sinusoid(x, z);
                // return texture2D(heightSampler, uv).z;
            }
            
            float height(vec3 p)
            {
                return height(p.x, p.z);
            }
            
            float frac(float x)
            {
                return x - floor(x);
            }
            
            vec3 getBoxNormal(vec3 p)
            {
                vec3 n = vec3((distBox(p+vec3(EPS,0,0))-distBox(p)),
                            (distBox(p+vec3(0,EPS,0))-distBox(p)),
                            (distBox(p+vec3(0,0,EPS))-distBox(p)));
                return normalize(n);
            }
            
            vec3 getSurfaceNormal(vec3 p)
            {
                vec3 n = vec3(height(p.x - EPS, p.z) - height(p.x + EPS, p.z),
                            2.0 * EPS,
                            height(p.x, p.z - EPS) - height(p.x, p.z + EPS));
                return normalize(n);
            }
            
            float getCaustics(vec3 p)
            {
                vec2 uv = (p.xz + vec2(1.0)) * 0.5;
                vec4 caustics = texture2D(causticsSampler, uv);
                float intensity = caustics.x;
                return pow(intensity,2.0)*15.0;
            }
            
            vec4 getCheckerBoard(vec3 p)
            {
                float numTiles = 40.0;
                float x = floor((p.x + 2.0) * 0.25 * numTiles);
                float y = floor((p.y + 2.0) * 0.25 * numTiles);
                float z = floor((p.z + 2.0) * 0.25 * numTiles);
                bool isSame = (frac(x * 0.5) < EPS) == (frac(z * 0.5) < EPS);
                isSame = (frac(y * 0.5) < EPS) ? isSame : !isSame;
                return isSame ? vec4(0.1) : vec4(0.9);
            }

            vec4 getCheckerBoardFlat(vec3 p)
            {
                float numTiles = 40.0;
                float x = floor((p.x + 2.0) * 0.25 * numTiles);
                float z = floor((p.z + 2.0) * 0.25 * numTiles);
                bool isSame = (frac(x * 0.5) < EPS) == (frac(z * 0.5) < EPS);
                return isSame ? vec4(0.1) : vec4(0.9);
            }
            
            vec4 getPic(vec3 p, sampler2D sampler)
            {
                vec2 uv = (p.xz + vec2(1.0)) * 0.5;
                return texture2D(sampler, uv);
            }
            
            vec3 reflection(vec3 v, vec3 n)
            {
                return -v + 2.0 * dot(v, n) * n;
            }
            
            float intensity(vec3 eye, vec3 p, vec3 n,
                            float kSpec, float specWeight, float diffWeight)
            {
                vec3 toLight = normalize(light1 - p);
                vec3 toEye = normalize(eye - p);
                vec3 ref = normalize(reflection(toLight, n));
            
                float diffuse = 0.0;
                float specular = 0.0;
            
                // Do diffuse lighting
                diffuse +=  max(0.0, dot(toLight, n));
                // Do specular lighting
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);
            
                // Recompute for second light
                toLight = normalize(light2 - p);
                ref = normalize(reflection(toLight, n));
                diffuse += max(0.0, dot(toLight, ref));
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);
            
                // Recompute for third light
                toLight = normalize(light3 - p);
                ref = normalize(reflection(toLight, n));
                diffuse += max(0.0, dot(toLight, ref));
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);
            
                return specWeight * specular + diffWeight * diffuse;
            }
            
            vec3 getRefractedDir(vec3 dir, vec3 n)
            {
                float costheta = dot(dir, -n);
                float ratio = AIR_IOR / WATER_IOR;
                float c = ratio * ratio * (1.0 - costheta * costheta);
                return ratio * dir + (ratio * costheta - sqrt(1.0 - c)) * n;
            }
            
            vec4 shadeWall(vec3 eye, vec3 p, vec3 normal)
            {
                return 0.5 * intensity(eye, p, normal, 0.0, 0.0, 1.0) * getCheckerBoard(p);
            }
            
            vec4 shadeFloor(vec3 eye, vec3 p)
            {
                return 0.5 * intensity(eye, p, vec3(0.0, 1.0, 0.0), 0.0, 0.0, 1.0) * getCheckerBoardFlat(p);
            }

            vec4 shadeSky(vec3 p)
            {
                return getPic(p, skySampler);
            }

            vec4 shadeWater(vec3 eye, vec3 p, vec3 normal)
            {
                return intensity(eye, p, normal, 50.0, 2.0, 0.0) * vec4(1.0);
            }
            
            vec3 getCartesian(vec3 sphericalCoord)
            {
                float radius = sphericalCoord.x;
                float phi = sphericalCoord.y;
                float theta = sphericalCoord.z;
                return vec3(
                    radius * sin(phi) * cos(theta),
                    radius * cos(phi),
                    radius * sin(phi) * sin(theta)
                );
            }
            
            vec3 getRightVector(vec3 coord)
            {
                return vec3(sin(coord.z), 0.0, -cos(coord.z));
            }
            
            bool outOfBox(vec3 p)
            {
                return max(abs(p.x), abs(p.z)) > 1.0;
            }
            
            bool hitFloor(vec3 p, vec3 dir, inout vec3 floorPos)
            {
                float t = (-TANK_HEIGHT - p.y)/dir.y;
                floorPos = p + t*dir;
                return max(abs(floorPos.x), abs(floorPos.z)) < FLOOR_WIDTH;
            }

            bool hitBox(inout vec3 p, const vec3 dir)
            {
                for (int i = 0; i < 50; i++) 
                {
                    float d = p.y < height(p) ? distBox(p) : distWaveBbox(p);
                    if (d < EPS)
                    {
                        return true;
                    }
                    p += dir * d;
                }
                return false;
            }

            bool hitSurface(const vec3 dir, const vec3 eye, inout vec3 p, inout vec4 surfaceColor, bool invertNormal)
            {
                for (int i = 0; i < MAXSTEPS; i++)
                {
                    // When we hit very close to the surface
                    if (p.y < height(p))
                    {
                        vec3 n = invertNormal ? -getSurfaceNormal(p) : getSurfaceNormal(p);
                        surfaceColor += shadeWater(eye, p, getSurfaceNormal(p));
                        return true;
                    }
        
                    // Checks if the ray hits the box from the inside
                    if (distWaveBbox(p) >= EPS)
                    {
                        return false;
                    }
        
                    p += dir * STEPSIZE;
                }
                return true;
            }
            
            void main()
            {
                vec3 eye = getCartesian(eyeCoordinate);
                vec3 focus = vec3(0, 0, 0);
                vec3 forward = normalize(focus - eye);
                vec3 right = normalize(getRightVector(eyeCoordinate));
                vec3 up = normalize(cross(right, forward));
            
                float f = 2.0;
                float u = gl_FragCoord.x * 2.0 / resolution.x - 1.0;
                float v = gl_FragCoord.y * 2.0 / resolution.y - 1.0;
            
                float ar = resolution.x / resolution.y;
                right *= ar;
            
                vec3 imagePos = eye + right * u + up * v + forward * f;
                vec3 dir = normalize(imagePos - eye);
            
                vec4 surfaceColor = vec4(0.0);
                vec4 boxColor = vec4(0.0);
                vec4 background = vec4(0.9);
                vec4 wallColor = background;

                vec3 p = eye;
            
                vec3 floorPos = vec3(0.0);
                if (!hitFloor(p, dir, floorPos))
                {
                    discard;
                }

                if (!hitBox(p, dir))
                {
                    gl_FragColor = shadeFloor(eye, floorPos);
                    return;
                }
                
                vec3 n = vec3(0.0);
                bool shootingUp = p.y > eye.y; 

                // If the part we hit is below the surface
                if (p.y < height(p))
                {
                    surfaceColor = shadeWater(eye, p, getBoxNormal(p));
                    n = getBoxNormal(p);
                }
                // If the part we hit is above the surface
                else
                {
                    if (shootingUp)
                    {
                        gl_FragColor = background;
                        return;
                    }
                        
                    if (hitSurface(dir, eye, p, surfaceColor, /*invertNormal*/ true))
                        n = getSurfaceNormal(p);
                    else
                    {
                        vec3 floorPos = vec3(0.0);
                        gl_FragColor = hitFloor(p, dir, floorPos) ? shadeFloor(eye, floorPos) : background;
                        return;
                    }
                }
            
                // Calculate refraction when hit box or surface
                vec3 air_dir = dir;
                dir = getRefractedDir(dir, n);
            
                // Step out of the box and step backwards until we hit it
                p += OVERSTEP * dir;
                if (!hitBox(p, -dir))
                {
                    // Sanity check. This should not happen since its
                    // guaranteed to hit the box at this stage
                    gl_FragColor = background;
                    return;
                }

                // If point is still above the surface, we constant raymarch to surface
                if (p.y > height(p))
                {
                    if (!hitSurface(-dir, eye, p, surfaceColor, /*invertNormal*/ false))
                    {
                        wallColor = shadeWall(eye, p, -getBoxNormal(p));
                    }
                    else
                    {
                        wallColor = shadeSky(p);
                    }
                }
                else
                {
                    //if hit the side of the box
                    if (p.y > -TANK_HEIGHT)
                    {
                        wallColor = shadeWater(eye, p, -getBoxNormal(p));
                        vec3 floorPos = vec3(0.0);
                        if (hitFloor(p, air_dir, floorPos))
                        {
                            wallColor += shadeFloor(eye, floorPos);
                        }
                    }
                    //else hit the bottom of the tank
                    else
                    {
                        wallColor = shadeFloor(eye, p) + vec4(getCaustics(p));
                    }
                }
                
                vec4 tint = vec4(0.1, 0.8, 0.9, 1.0);
                gl_FragColor = 0.3 * (surfaceColor + tint) + wallColor;
            }
    </script>
    <script id="fs1" type="x-shader/fragment">
            uniform float time;
            uniform vec2 resolution;
            uniform sampler2D sampler;

            vec4 sample(vec2 uv)
            {
                if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
                {
                    return vec4(0.0);
                }
                return texture2D(sampler, uv);
            }

            void main()
            {
                vec2 EPS = vec2(0.01, 0);
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 U = sample(uv);

                vec4 Uxf = sample(uv + EPS.xy);
                vec4 Uxb = sample(uv - EPS.xy);
                vec4 Uxx = (Uxf - 2.0 * U + Uxb) / (EPS.x * EPS.x);

                vec4 Uyf = sample(uv + EPS.yx);
                vec4 Uyb = sample(uv - EPS.yx);
                vec4 Uyy = (Uyf - 2.0 * U + Uyb) / (EPS.x * EPS.x);

                float dt = EPS.x * EPS.x * 0.2;

                gl_FragColor = U + dt * (Uyy + Uxx);
            }
    </script>
    <script id="fs2" type="x-shader/fragment">
            #define TIMESTEP 0.01
            #define H 1.0/100.0
        
            uniform float time;
            uniform vec2 resolution;
            uniform sampler2D sampler;

            vec4 lerp(vec4 a, vec4 b, float t)
            {
            	return (1.0 - t) * a + t * b;
            }

            vec4 sample(vec2 uv)
            {
            	vec4 result;
                if (uv.x < 0.0 && uv.x >= -H)
                {
                    vec4 U = texture2D(sampler, vec2(0.0, uv.y));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = -uv.x;
                    result = lerp(U, V, s / H);
                }
                else if (uv.x > 1.0 && uv.x <= 1.0 + H)
                {
                	vec4 U = texture2D(sampler, vec2(1.0, uv.y));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                	float s = uv.x - 1.0;
                	result = lerp(U, V, s / H);
                }
                else if (uv.y < 0.0 && uv.y >= -H)
                {
                    vec4 U = texture2D(sampler, vec2(uv.x, 0.0));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = -uv.y;
                    result = lerp(U, V, s / H);
                }
                else if (uv.y > 1.0 && uv.y <= 1.0 + H)
                {
                    vec4 U = texture2D(sampler, vec2(uv.x, 1.0));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = uv.y - 1.0;
                    result = lerp(U, V, s / H);
                }
                else if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
                {
                    result = vec4(0.0);
                }
                else
                {
                	result = texture2D(sampler, uv);
                }
                return result;
            }

            vec4 advect(vec2 uv)
            {
                vec2 vel = sample(uv).xy;
                vel *= -TIMESTEP;
                uv -= vel;
                return sample(uv);
            }

            void main()
            {
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                gl_FragColor = advect(uv);
            }
    </script> 
    <script id="fs3" type="x-shader/fragment">
            #define TIMESTEP 0.01
            #define G -10.0
            #define H 1.0/100.0
        
            uniform vec2 resolution;
            uniform sampler2D sampler;

            vec4 lerp(vec4 a, vec4 b, float t)
            {
            	return (1.0 - t) * a + t * b;
            }

            vec4 sample(vec2 uv)
            {
            	vec4 result;
                if (uv.x < 0.0 && uv.x >= -H)
                {
                    vec4 U = texture2D(sampler, vec2(0.0, uv.y));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = -uv.x;
                    result = lerp(U, V, s / H);
                }
                else if (uv.x > 1.0 && uv.x <= 1.0 + H)
                {
                	vec4 U = texture2D(sampler, vec2(1.0, uv.y));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                	float s = uv.x - 1.0;
                	result = lerp(U, V, s / H);
                }
                else if (uv.y < 0.0 && uv.y >= -H)
                {
                    vec4 U = texture2D(sampler, vec2(uv.x, 0.0));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = -uv.y;
                    result = lerp(U, V, s / H);
                }
                else if (uv.y > 1.0 && uv.y <= 1.0 + H)
                {
                    vec4 U = texture2D(sampler, vec2(uv.x, 1.0));
                    vec4 V = vec4(-1.0, -1.0, 1.0, 0.0) * U;
                    float s = uv.y - 1.0;
                    result = lerp(U, V, s / H);
                }
                else if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)
                {
                    result = vec4(0.0);
                }
                else
                {
                	result = texture2D(sampler, uv);
                }
                return result;
            }

            float cenDiff(float f, float b, float eps)
            {
                return (f - b) / (2.0 * eps);
            }

            void main()
            {
                vec2 eps = vec2(H, 0.0);
                vec2 uv = gl_FragCoord.xy / resolution.xy;
                vec4 U = sample(uv);

                // Forward and backward differences in x and z
                vec4 Uxf = sample(uv + eps.xy);
                vec4 Uxb = sample(uv - eps.xy);
                vec4 Uzf = sample(uv + eps.yx);
                vec4 Uzb = sample(uv - eps.yx);

                // Compute velocities at the faces
                vec4 n = sample(uv + eps.yx);
                vec4 s = sample(uv - eps.yx);
                vec4 e = sample(uv + eps.xy);
                vec4 w = sample(uv - eps.xy);
                vec2 avgn = (n.xy + U.xy) * 0.5;
                vec2 avgs = (s.xy + U.xy) * 0.5;
                vec2 avge = (e.xy + U.xy) * 0.5;
                vec2 avgw = (w.xy + U.xy) * 0.5;

                // Compute pressures at the corners
                float pne = sample(uv + eps.xx * 0.5).z;
                float pnw = sample(uv - eps.xy * 0.5 + eps.yx * 0.5).z;
                float pse = sample(uv + eps.xy * 0.5 - eps.yx * 0.5).z;
                float psw = sample(uv - eps.xx * 0.5).z;

                // Compute pressure gradients at faces
                vec2 pgn = vec2(pne - pnw, n.z - U.z) / H;
                vec2 pgs = vec2(pse - psw, U.z - s.z) / H;
                vec2 pge = vec2(e.z - U.z, pne - pse) / H;
                vec2 pgw = vec2(U.z - w.z, pnw - psw) / H;

                avgn += TIMESTEP * G * pgn;
                avgs += TIMESTEP * G * pgs;
                avge += TIMESTEP * G * pge;
                avgw += TIMESTEP * G * pgw;

                vec2 vel = (avgn + avgs + avge + avgw) * 0.25;

                float dudx = cenDiff(Uxf.x, Uxb.x, eps.x);
                float dwdz = cenDiff(Uzf.y, Uzb.y, eps.x);
                float h = U.z - TIMESTEP * U.z * (dudx + dwdz);
                
                gl_FragColor = vec4(vel, h, 0.0);
            }
    </script>
    <script id="fs4" type="x-shader/fragment">  
            varying vec3 start1;
            varying vec3 end1;
            varying vec3 start3; 
            varying vec3 end3;

            float getArea(vec3 pos)
            {
                return length(dFdx(pos)) * length(dFdy(pos));
            }

            void main()
            {
                gl_FragColor = vec4(
                    getArea(start3)/getArea(end3), 
                    1.0, 1.0, 1.0);
            }
    </script> 
    <script>
            window.requestAnimationFrame = window.requestAnimationFrame || (function ()
            {
                return window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function (callback, element)
                    {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();
            var canvas
                , gl
                , buffer
                , vertex_shader, fragment_shader, heightfield_shader
                , heightProgram
                , renderProgram
                , vertex_position = 0
                , timeLocation
                , resolutionLocation
                , frame
                , parameters = {
                    start_time: new Date().getTime()
                    , time: 0
                    , screenWidth: 0
                    , screenHeight: 0
                };
            //load();
            init();
            animate();

            function read(textfile, id, type)
            {
                return new Promise((resolve, reject) =>
                {
                    var request = new XMLHttpRequest();
                    request.open('GET', textfile, true);
                    request.onload = () => resolve((id, type) => this.show);
                    request.onerror = () => reject(request.statusText);
                    request.send()
                })
            }

            function show(id, type)
            {
                var script = document.createElement('script')
                script.id = id
                script.type = type
                script.textContent = this.response;
                document.body.appendChild(script)
            }

            function load()
            {
                vs_promise = read('vertex.shader', 'vs', "x-shader/vertex").then(() =>
                {
                    fs_promise = read('heightfield.frag', 'fs', "x-shader/fragment").then(() =>
                    {
                        init()
                    })
                })
            }

            function init()
            {
                vertex_shader = document.getElementById('vs0').textContent;
                fragment_shader = document.getElementById('fs0').textContent;
                heightfield_shader = document.getElementById('fs2').textContent;
                gravity_shader = document.getElementById('fs3').textContent;

                // Caustics
                caustics_vs = document.getElementById('vs1').textContent;
                caustics_fs = document.getElementById('fs4').textContent;
                
                canvas = document.querySelector('canvas');

                // Initialise WebGL
                try
                {
                    gl = canvas.getContext('experimental-webgl');
                } catch (error) {}

                if (!gl)
                {
                    throw "cannot create webgl context";
                }

                // Extensions
                gl.getExtension('OES_texture_float');
                gl.getExtension('OES_texture_float_linear');
                gl.getExtension('OES_standard_derivatives');

                // Create Vertex buffer (2 triangles)
                buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), gl.STATIC_DRAW);

                // Create Buffer for the Light Wavefront 
                createLightWaveBuffer();

                // Create Frame Buffer for storing the height field
                initFrameBuffers();

                // Create Programs
                initHeightProgram();
                initGravityProgram();
                initCausticsProgram();
                initRenderProgram();

                wallTexture = loadTexture(gl, "black.jpg");
                skyTexture = loadTexture(gl, "tiles.jpg");

                canvas.onmousedown = handleMouseDown;
                canvas.onmousemove = handleMouseMove;
                canvas.onmouseup = handleMouseUp;
                canvas.onwheel = handleWheelScroll;

                mousedown = false;
                mouseDownX = null;
                mouseDownY = null;
                eyeCoordinate = {
                    radius : 3,
                    phi : 0.785, 
                    theta : 0.785
                };
            }

            function createLightWaveBuffer()
            {
                // Resolution
                var width = 300;
                var height = 300;
                lightWaveVertices = [];
                
                for (i = 0; i < height; i++)
                {
                    for (j = 0; j < width; j++)
                    {
                        var v1x = (i/height)*2 - 1;
                        var v1y = (j/width)*2 - 1;
                        var v2x = ((i+1)/height)*2 - 1;
                        var v2y = ((j+1)/width)*2 - 1;
                        // Triangle 1
                        lightWaveVertices.push.apply(lightWaveVertices, [v1x, v1y]);
                        lightWaveVertices.push.apply(lightWaveVertices, [v1x, v2y]);
                        lightWaveVertices.push.apply(lightWaveVertices, [v2x, v2y]);
                        // Triangle 2 
                        lightWaveVertices.push.apply(lightWaveVertices, [v1x, v1y]);
                        lightWaveVertices.push.apply(lightWaveVertices, [v2x, v2y]);
                        lightWaveVertices.push.apply(lightWaveVertices, [v2x, v1y]);
                    }
                }


                lightWaveBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, lightWaveBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lightWaveVertices), gl.STATIC_DRAW);
            }

            function initCausticsProgram()
            {
                causticsProgram = createProgram(caustics_vs, caustics_fs);
                causticsUniform = {
                    timeLocation : gl.getUniformLocation(causticsProgram, 'time')
                    ,light1 : gl.getUniformLocation(causticsProgram, 'light1')
                    ,light2 : gl.getUniformLocation(causticsProgram, 'light2')
                    ,light3 : gl.getUniformLocation(causticsProgram, 'light3')
                }
            }

            function initGravityProgram()
            {
                gravityProgram = createProgram(vertex_shader, gravity_shader);
                gravityUniforms = {
                    resolutionLocation : gl.getUniformLocation(gravityProgram, 'resolution')
                    ,samplerLocation : gl.getUniformLocation(gravityProgram, 'sampler')
                };
            }

            function initRenderProgram()
            {
                renderProgram = createProgram(vertex_shader, fragment_shader);
                renderUniforms = {
                    timeLocation : gl.getUniformLocation(renderProgram, 'time')
                    ,resolutionLocation : gl.getUniformLocation(renderProgram, 'resolution')
                    ,heightSamplerLocation : gl.getUniformLocation(renderProgram, 'heightSampler')
                    ,wallSamplerLocation : gl.getUniformLocation(renderProgram, 'wallSampler')
                    ,skySamplerLocation : gl.getUniformLocation(renderProgram, 'skySampler')
                    ,causticsSamperLocation : gl.getUniformLocation(renderProgram, 'causticsSampler')
                    ,eyeCoordinate : gl.getUniformLocation(renderProgram, 'eyeCoordinate')
                    ,light1 : gl.getUniformLocation(renderProgram, 'light1')
                    ,light2 : gl.getUniformLocation(renderProgram, 'light2')
                    ,light3 : gl.getUniformLocation(renderProgram, 'light3')
                };
            }

            function initHeightProgram()
            {
                heightProgram = createProgram(vertex_shader, heightfield_shader);
                heightUniforms = {
                    timeLocation : gl.getUniformLocation(heightProgram, 'time')
                    ,resolutionLocation : gl.getUniformLocation(heightProgram, 'resolution')
                    ,samplerLocation : gl.getUniformLocation(heightProgram, 'sampler')
                }
            }

            function initFrameBuffers()
            {
                width = 100;
                height = 100;
                heightFrameBuffer0 = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer0);
                heightFrameBuffer0.width = width;
                heightFrameBuffer0.height = height;

                heightTexture0 = loadFloatTexture(gl, width, height);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, heightTexture0, 0);

                heightFrameBuffer1 = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer1);
                heightFrameBuffer1.width = width;
                heightFrameBuffer1.height = height;

                heightTexture1 = loadFloatTexture(gl, width, height);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, heightTexture1, 0);

                // Caustics Frame Buffer & Texture
                causticsFrameBuffer = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, causticsFrameBuffer);
                causticsFrameBuffer.width = 500;
                causticsFrameBuffer.height = 500;
                causticsTexture = loadEmptyTexture(gl, causticsFrameBuffer);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, causticsTexture, 0);

                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                frame = 0;
            }

            function createProgram(vertex, fragment)
            {
                var program = gl.createProgram();
                var vs = createShader(vertex, gl.VERTEX_SHADER);
                var fs = createShader('#extension GL_OES_standard_derivatives : enable\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER);
                if (vs == null || fs == null) return null;

                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.deleteShader(vs);
                gl.deleteShader(fs);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS))
                {
                    alert("ERROR:\n" +
                        "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
                        "ERROR: " + gl.getError() + "\n\n" +
                        "- Vertex Shader -\n" + vertex + "\n\n" +
                        "- Fragment Shader -\n" + fragment);
                    return null;
                }

                return program;
            }

            function createShader(src, type)
            {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                {
                    alert((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            function loadEmptyTexture(gl, framebuffer)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, framebuffer.width, framebuffer.height, 0,
                            gl.RGBA, gl.FLOAT, null);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                return texture;
            }

            function loadFloatTexture(gl, w, h)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                var heightMap = new Float32Array(w * h * 4);

                for (var i = 0; i < w; i++)
                {
                    for (var j = 0; j < h; j++)
                    {
                        var x = (i / (h * 0.5)) - 1.0;
                        var z = (j / (w * 0.5)) - 1.0;
                        var t = x * x + z * z;
                        heightMap[(i * w + j) * 4 + 0] = Math.sin(x);
                        heightMap[(i * w + j) * 4 + 1] = Math.cos(z);
                        heightMap[(i * w + j) * 4 + 2] = 0.1 * Math.exp(-t) * Math.sin(10.0 * t);
                        heightMap[(i * w + j) * 4 + 3] = 0.0;
                    }
                }   

                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, 
                            gl.RGBA, gl.FLOAT, heightMap);
                // if (isPowerOf2(w) && isPowerOf2(h)) 
                // {
                //     gl.generateMipmap(gl.TEXTURE_2D);
                // }
                if (true) 
                {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                }
                return texture;
            }

            function loadTexture(gl, url)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 125, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

                const image = new Image();
                image.onload = function() 
                {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                                srcFormat, srcType, image);
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) 
                    {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } 
                    else 
                    {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                };
                image.src = url;

                return texture;
            }

            function isPowerOf2(value)
            {
                return (value & (value - 1)) == 0;
            }

            function resizeCanvas(event)
            {
                if (canvas.width != canvas.clientWidth ||
                    canvas.height != canvas.clientHeight)
                {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    parameters.screenWidth = canvas.width;
                    parameters.screenHeight = canvas.height;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            }

            function handleMouseDown(event)
            {
                mousedown = true;
                mouseDownX = event.clientX;
                mouseDownY = event.clientY;
            }

            function handleMouseUp(event)
            {
                mousedown = false;
            }

            function handleMouseMove(event)
            {
                if (!mousedown)
                {
                    return;
                }

                var currentX = event.clientX;
                var currentY = event.clientY;
                var deltaX = currentX - mouseDownX;
                var deltaY = currentY - mouseDownY;
                eyeCoordinate.theta += (deltaX/10)/180 * Math.PI;
                eyeCoordinate.phi += (-deltaY/10)/180 * Math.PI; 

                mouseDownY = currentY;
                mouseDownX = currentX;
            }

            function handleWheelScroll(event)
            {
                var new_radius = eyeCoordinate.radius + event.deltaY/100.0;
                if (new_radius > 0.0)
                {
                    eyeCoordinate.radius = new_radius;
                }
            }

            function animate()
            {
                resizeCanvas();
                render();
                requestAnimationFrame(animate);
            }

            function render()
            {
                if (!renderProgram) return;
                parameters.time = new Date().getTime() - parameters.start_time;
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // First Draw Call: Compute Height Field
                gl.useProgram(heightProgram);
                // Set which buffer to write to
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer0);
                // Set which texture to read from
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, heightTexture1);

                gl.viewport(0, 0, heightFrameBuffer0.width, heightFrameBuffer0.height);
                gl.uniform1f(heightUniforms.timeLocation, parameters.time / 1000);
                gl.uniform2f(heightUniforms.resolutionLocation, heightFrameBuffer0.width, heightFrameBuffer0.height);
                gl.uniform1i(heightUniforms.samplerLocation, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disableVertexAttribArray(vertex_position);

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                // Second Draw Call: Gravity
                gl.useProgram(gravityProgram);
                
                // write
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer1);
                
                // read
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, heightTexture0);

                gl.viewport(0, 0, heightFrameBuffer0.width, heightFrameBuffer0.height);
                gl.uniform2f(gravityUniforms.resolutionLocation, heightFrameBuffer0.width, heightFrameBuffer0.height);
                gl.uniform1i(gravityUniforms.samplerLocation, 0);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disableVertexAttribArray(vertex_position);
                
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                // Third Draw Call: Caustics
                gl.useProgram(causticsProgram);

                gl.bindFramebuffer(gl.FRAMEBUFFER, causticsFrameBuffer);
                gl.viewport(0, 0, causticsFrameBuffer.width, causticsFrameBuffer.height);
                gl.uniform1f(causticsUniform.timeLocation, parameters.time / 1000);
                gl.uniform3f(causticsUniform.light1, 2.0, 2.0, 2.0)
                gl.uniform3f(causticsUniform.light2, -2.0, 2.0, -2.0);
                gl.uniform3f(causticsUniform.light3, 0.0, 2.0, 0.0);

                gl.bindBuffer(gl.ARRAY_BUFFER, lightWaveBuffer);
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, lightWaveVertices.length/2);
                gl.disableVertexAttribArray(vertex_position);

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                // Fourth Draw Call: Render
                gl.useProgram(renderProgram);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, heightTexture1);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, wallTexture);
                gl.activeTexture(gl.TEXTURE2);
                gl.bindTexture(gl.TEXTURE_2D, causticsTexture);
                gl.activeTexture(gl.TEXTURE3);
                gl.bindTexture(gl.TEXTURE_2D, skyTexture);
                
                gl.viewport(0, 0, parameters.screenWidth, parameters.screenHeight);

                // Set values to program variables
                gl.uniform1f(renderUniforms.timeLocation, parameters.time / 1000);
                gl.uniform2f(renderUniforms.resolutionLocation, parameters.screenWidth, parameters.screenHeight);
                gl.uniform1i(renderUniforms.heightSamplerLocation, 0);
                gl.uniform1i(renderUniforms.wallSamplerLocation, 1);
                gl.uniform1i(renderUniforms.causticsSamperLocation, 2);
                gl.uniform1i(renderUniforms.skySamplerLocation, 3);
                gl.uniform3f(renderUniforms.eyeCoordinate, eyeCoordinate.radius, eyeCoordinate.phi, eyeCoordinate.theta);
                gl.uniform3f(renderUniforms.light1, 2.0, 2.0, 2.0);
                gl.uniform3f(renderUniforms.light2, -2.0, 2.0, -2.0);
                gl.uniform3f(renderUniforms.light3, 0.0, 2.0, 0.0);

                // Render geometry
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disableVertexAttribArray(vertex_position);

                frame = (frame + 1) % 2;
            }

    </script>
</body>
</html>