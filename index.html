<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <title>Shallow Water</title>
    <style>
            html, body {
                background-color: #000000;
                margin: 0px;
                overflow: hidden;
                width: 100%;
                height: 100%;
            }
            canvas {
                width: 100%;
                height: 100%;
            }
    </style>
</head>
<body>
    <canvas></canvas>
    <div id="info"></div>
    <script id="vs" type="x-shader/vertex">
            attribute vec3 position;
            void main() {
                gl_Position = vec4( position, 1.0 );
            }
    </script>
    <script id="fs0" type="x-shader/fragment">
            #define EPS 0.01
            #define STEPSIZE 0.01
            #define MAXSTEPS 1000
            #define FREQ 20.0
            #define AMP 0.05
            #define OVERSTEP 4.0
            #define AIR_IOR 1.0
            #define WATER_IOR 1.33

            uniform float time;
            uniform vec2 resolution;
            uniform sampler2D heightSampler;
            uniform sampler2D wallSampler;
            uniform vec3 eyeCoordinate;

            vec3 light1 = vec3(2.0, 2.0, 2.0);
            vec3 light2 = vec3(-2.0, 2.0, -2.0);
            vec3 light3 = vec3(0.0, 1.0, 0.0);

            float distBox(vec3 p)
            {
                vec3 b = vec3(1.0, 1.0, 1.0);
                vec3 d = abs(p) - b;
                return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
            }

            float sinusoid(float x, float z)
            {
                float t = x * x * sin(time) + z * z * cos(time);
                return AMP * exp(-t) * cos(FREQ * t);
            }

            float height(float x, float z)
            {
                vec2 uv = (vec2(x, z) + vec2(1.0)) * 0.5;
                return texture2D(heightSampler, uv).z;
            }

            float height(vec3 p)
            {
                return height(p.x, p.z);
            }

            float frac(float x)
            {
                return x - floor(x);
            }

            vec3 getBoxNormal(vec3 p)
            {
                vec3 n = vec3((distBox(p+vec3(EPS,0,0))-distBox(p)),
                              (distBox(p+vec3(0,EPS,0))-distBox(p)),
                              (distBox(p+vec3(0,0,EPS))-distBox(p)));
                return normalize(n);
            }

            vec3 getSurfaceNormal(vec3 p)
            {
                vec3 n = vec3(height(p.x - EPS, p.z) - height(p.x + EPS, p.z),
                              2.0 * EPS,
                              height(p.x, p.z - EPS) - height(p.x, p.z + EPS));
                return normalize(n);
            }

            vec4 getCheckerBoard(vec3 p)
            {
                float numTiles = 20.0;
                float x = floor((p.x + 1.0) * 0.5 * numTiles);
                float y = floor((p.y + 1.0) * 0.5 * numTiles);
                float z = floor((p.z + 1.0) * 0.5 * numTiles);
                bool isSame = (frac(x * 0.5) < EPS) == (frac(z * 0.5) < EPS);
                isSame = (frac(y * 0.5) < EPS) ? isSame : !isSame;
                return isSame ? vec4(0.0, 0.6, 0.9, 1.0) : vec4(0.1);
            }

            vec4 getPic(vec3 p)
            {
                vec2 uv = (p.xz + vec2(1.0)) * 0.5;
                return texture2D(wallSampler, uv);
            }

            vec3 reflection(vec3 v, vec3 n)
            {
                return -v + 2.0 * dot(v, n) * n;
            }

            float intensity(vec3 eye, vec3 p, vec3 n,
                            float kSpec, float specWeight, float diffWeight)
            {
                vec3 toLight = normalize(light1 - p);
                vec3 toEye = normalize(eye - p);
                vec3 ref = normalize(reflection(toLight, n));

                float diffuse = 0.0;
                float specular = 0.0;

                // Do diffuse lighting
                diffuse +=  max(0.0, dot(toLight, n));
                // Do specular lighting
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);

                // Recompute for second light
                toLight = normalize(light2 - p);
                ref = normalize(reflection(toLight, n));
                diffuse += max(0.0, dot(toLight, ref));
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);

                // Recompute for third light
                toLight = normalize(light3 - p);
                ref = normalize(reflection(toLight, n));
                diffuse += max(0.0, dot(toLight, ref));
                specular += pow(max(dot(ref, toEye), 0.0), kSpec);

                return specWeight * specular + diffWeight * diffuse;
            }

			vec3 getRefractedDir(vec3 dir, vec3 n)
			{
				float costheta = dot(dir, -n);
				float ratio = AIR_IOR / WATER_IOR;
				float c = ratio * ratio * (1.0 - costheta * costheta);
				return ratio * dir + (ratio * costheta - sqrt(1.0 - c)) * n;
			}

            vec4 shadeWall(vec3 eye, vec3 p, vec3 normal)
            {
                return intensity(eye, p, normal, 0.0, 0.0, 1.0) * getPic(p);
            }

            vec4 shadeWater(vec3 eye, vec3 p, vec3 normal)
            {
                return intensity(eye, p, normal, 50.0, 2.0, 0.0) * vec4(1.0);
            }

            vec3 getCartesian(vec3 sphericalCoord)
            {
                float radius = sphericalCoord.x;
                float phi = sphericalCoord.y;
                float theta = sphericalCoord.z;
                return vec3(
                    radius * sin(phi) * cos(theta),
                    radius * cos(phi),
                    radius * sin(phi) * sin(theta)
                );
            }
        
            void main()
            {
                //vec3 eye = 3.0 * vec3(1.0);
                //vec3 eye = 3.0 * vec3(sin(time), 1.0, cos(time));
                vec3 eye = getCartesian(eyeCoordinate);
                vec3 focus = vec3(0, 0, 0);
                vec3 forward = normalize(focus - eye);
                vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));
                vec3 up = normalize(cross(right, forward));

                float f = 2.0;
                float u = gl_FragCoord.x * 2.0 / resolution.x - 1.0;
                float v = gl_FragCoord.y * 2.0 / resolution.y - 1.0;

                float ar = resolution.x / resolution.y;
                right *= ar;

                vec3 imagePos = eye + right * u + up * v + forward * f;
                vec3 dir = normalize(imagePos - eye);

                vec4 surfaceColor = vec4(0.0);
                vec4 boxColor = vec4(0.0);

                bool hitBox = false;
                bool hitSurface = false;

                // Ray march until we hit the bounding box
                vec3 p = eye;
                for (int i = 0; i < 50; i++) {
                    float d = distBox(p);
                    if(d < EPS)
                    {
                        hitBox = true;
                        break;
                    }
                    p += dir * d;
                }

                // If we miss the box we just color in a black background
                if (!hitBox)
                {
                    gl_FragColor = vec4(0.0);
                    return;
                }

                hitBox = false;
                // If the part we hit is below the surface
                if (p.y < height(p))
                {
                    surfaceColor = shadeWater(eye, p, getBoxNormal(p));
                    hitSurface = true;
                    hitBox = true;
                }
                // If the part we hit is above the surface
                else
                {
                    for (int i = 0; i < MAXSTEPS; i++)
                    {
                        // When we hit very close to the surface
                        if (p.y < height(p))
                        {
                            hitSurface = true;
                            surfaceColor = shadeWater(eye, p, getSurfaceNormal(p));
                            break;
                        }

                        // Checks if the ray hits the box from the inside
                        float d = distBox(p);
                        if (d >= EPS)
                        {
                            gl_FragColor = vec4(0.0);
                            return;
                        }

                        p += dir * STEPSIZE;
                    }
                }

                dir = getRefractedDir(dir, hitBox ? getBoxNormal(p) : getSurfaceNormal(p));

                // Step out of the box and step backwards until we hit it
                p += OVERSTEP * dir;
                for (int i = 0; i < MAXSTEPS; i++)
                {
                    float d = distBox(p);
                    if (d < EPS)
                    {
                        break;
                    }
                    p -= dir * d;
                }

                vec4 wallColor = shadeWall(eye, p, -getBoxNormal(p));
                gl_FragColor = 0.3 * surfaceColor + 0.5 * wallColor;
            }
    </script>
    <script id="fs1" type="x-shader/fragment">
            uniform float time;
            uniform vec2 resolution;
        
            float sinusoid(float x, float z)
            {
                float t = x * x * sin(time) + z * z * cos(time);
                return 0.05 * exp(-t) * cos(20.0 * t);
            }
            
            void main()
            {
                float u = gl_FragCoord.x * 2.0 / resolution.x - 1.0;
                float v = gl_FragCoord.y * 2.0 / resolution.y - 1.0;
                gl_FragColor = vec4(0.0, 0.0, sinusoid(u, v), 0.0);
            }
    </script>
    <script>
            window.requestAnimationFrame = window.requestAnimationFrame || (function ()
            {
                return window.webkitRequestAnimationFrame ||
                    window.mozRequestAnimationFrame ||
                    window.oRequestAnimationFrame ||
                    window.msRequestAnimationFrame ||
                    function (callback, element)
                    {
                        window.setTimeout(callback, 1000 / 60);
                    };
            })();
            var canvas
                , gl
                , buffer
                , vertex_shader, fragment_shader, heightfield_shader
                , heightProgram
                , renderProgram
                , vertex_position
                , timeLocation
                , resolutionLocation
                , parameters = {
                    start_time: new Date().getTime()
                    , time: 0
                    , screenWidth: 0
                    , screenHeight: 0
                };
            //load();
            init();
            animate();

            function read(textfile, id, type)
            {
                return new Promise((resolve, reject) =>
                {
                    var request = new XMLHttpRequest();
                    request.open('GET', textfile, true);
                    request.onload = () => resolve((id, type) => this.show);
                    request.onerror = () => reject(request.statusText);
                    request.send()
                })
            }

            function show(id, type)
            {
                var script = document.createElement('script')
                script.id = id
                script.type = type
                script.textContent = this.response;
                document.body.appendChild(script)
            }

            function load()
            {
                vs_promise = read('vertex.shader', 'vs', "x-shader/vertex").then(() =>
                {
                    fs_promise = read('heightfield.frag', 'fs', "x-shader/fragment").then(() =>
                    {
                        init()
                    })
                })
            }

            function init()
            {
                vertex_shader = document.getElementById('vs').textContent;
                fragment_shader = document.getElementById('fs0').textContent;
                heightfield_shader = document.getElementById('fs1').textContent;
                canvas = document.querySelector('canvas');

                // Initialise WebGL
                try
                {
                    gl = canvas.getContext('experimental-webgl');
                } catch (error) {}

                if (!gl)
                {
                    throw "cannot create webgl context";
                }

                // Extensions
                gl.getExtension('OES_texture_float');
                gl.getExtension('OES_texture_float_linear');    

                // Create Vertex buffer (2 triangles)
                buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), gl.STATIC_DRAW);

                // Create Frame Buffer for storing the height field
                initFrameBuffer();

                // Create Programs
                initHeightProgram();
                initRenderProgram();

                wallTexture = loadTexture(gl, "tiles.jpg");

                canvas.onmousedown = handleMouseDown;
                canvas.onmousemove = handleMouseMove;
                canvas.onmouseup = handleMouseUp;

                mousedown = false;
                mouseDownX = null;
                mouseDownY = null;
                eyeCoordinate = {
                    radius : 3,
                    phi : 0.785, 
                    theta : 0.785
                };
            }

            function initRenderProgram()
            {
                renderProgram = createProgram(vertex_shader, fragment_shader);
                renderUniforms = {
                    timeLocation : gl.getUniformLocation(renderProgram, 'time')
                    ,resolutionLocation : gl.getUniformLocation(renderProgram, 'resolution')
                    ,heightSamplerLocation : gl.getUniformLocation(renderProgram, 'heightSampler')
                    ,wallSamplerLocation : gl.getUniformLocation(renderProgram, 'wallSampler')
                    ,eyeCoordinate : gl.getUniformLocation(renderProgram, 'eyeCoordinate')
                };
            }

            function initHeightProgram()
            {
                heightProgram = createProgram(vertex_shader, heightfield_shader);
                heightUniforms = {
                    timeLocation : gl.getUniformLocation(heightProgram, 'time')
                    ,resolutionLocation : gl.getUniformLocation(heightProgram, 'resolution')
                }
            }

            function initFrameBuffer()
            {
                heightFrameBuffer = gl.createFramebuffer(); 
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer);
                heightFrameBuffer.width = 200;
                heightFrameBuffer.height = 200;

                heightTexture = loadEmptyTexture(gl);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, heightTexture, 0);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            }

            function createProgram(vertex, fragment)
            {
                var program = gl.createProgram();
                var vs = createShader(vertex, gl.VERTEX_SHADER);
                var fs = createShader('#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER);
                if (vs == null || fs == null) return null;

                gl.attachShader(program, vs);
                gl.attachShader(program, fs);
                gl.deleteShader(vs);
                gl.deleteShader(fs);
                gl.linkProgram(program);

                if (!gl.getProgramParameter(program, gl.LINK_STATUS))
                {
                    alert("ERROR:\n" +
                        "VALIDATE_STATUS: " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n" +
                        "ERROR: " + gl.getError() + "\n\n" +
                        "- Vertex Shader -\n" + vertex + "\n\n" +
                        "- Fragment Shader -\n" + fragment);
                    return null;
                }

                return program;
            }

            function createShader(src, type)
            {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, src);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
                {
                    alert((type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT") + " SHADER:\n" + gl.getShaderInfoLog(shader));
                    return null;
                }
                return shader;
            }

            function loadEmptyTexture(gl)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, heightFrameBuffer.width, heightFrameBuffer.height, 0, 
                            gl.RGBA, gl.FLOAT, null);
                if (isPowerOf2(heightFrameBuffer.width) && isPowerOf2(heightFrameBuffer.height)) 
                {
                    gl.generateMipmap(gl.TEXTURE_2D);
                } 
                else 
                {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
                }
                return texture;
            }

            function loadFloatTexture(gl)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                const w = 100;
                const h = 100;
                var heightMap = new Float32Array(w * h * 4);

                for (var i = 0; i < w; i++)
                {
                    for (var j = 0; j < h; j++)
                    {
                        heightMap[(i * w + j) * 4 + 0] = 0.0;
                        heightMap[(i * w + j) * 4 + 1] = 0.0;
                        heightMap[(i * w + j) * 4 + 2] = (i/100.0)*(i/100.0) + (j/100.0)*(j/100.0);
                        heightMap[(i * w + j) * 4 + 3] = 0.0;
                    }
                }   

                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, w, h, 0, 
                            gl.RGBA, gl.FLOAT, heightMap);
                if (isPowerOf2(w) && isPowerOf2(h)) 
                {
                    gl.generateMipmap(gl.TEXTURE_2D);
                } 
                else 
                {
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                }
                return texture;
            }

            function loadTexture(gl, url)
            {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);

                const level = 0;
                const internalFormat = gl.RGBA;
                const width = 1;
                const height = 1;
                const border = 0;
                const srcFormat = gl.RGBA;
                const srcType = gl.UNSIGNED_BYTE;
                const pixel = new Uint8Array([0, 125, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

                const image = new Image();
                image.onload = function() 
                {
                    gl.bindTexture(gl.TEXTURE_2D, texture);
                    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                                srcFormat, srcType, image);
                    if (isPowerOf2(image.width) && isPowerOf2(image.height)) 
                    {
                        gl.generateMipmap(gl.TEXTURE_2D);
                    } 
                    else 
                    {
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                    }
                };
                image.src = url;

                return texture;
            }

            function isPowerOf2(value)
            {
                return (value & (value - 1)) == 0;
            }

            function resizeCanvas(event)
            {
                if (canvas.width != canvas.clientWidth ||
                    canvas.height != canvas.clientHeight)
                {
                    canvas.width = canvas.clientWidth;
                    canvas.height = canvas.clientHeight;
                    parameters.screenWidth = canvas.width;
                    parameters.screenHeight = canvas.height;
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            }

            function handleMouseDown(event)
            {
                mousedown = true;
                mouseDownX = event.clientX;
                mouseDownY = event.clientY;
            }

            function handleMouseUp(event)
            {
                mousedown = false;
            }

            function handleMouseMove(event)
            {
                if (!mousedown)
                {
                    return;
                }

                var currentX = event.clientX;
                var currentY = event.clientY;
                var deltaX = currentX - mouseDownX;
                var deltaY = currentY - mouseDownY;
                eyeCoordinate.theta += (deltaX/10)/180 * Math.PI;
                eyeCoordinate.phi += (-deltaY/10)/180 * Math.PI; 

                mouseDownY = currentY;
                mouseDownX = currentX;
            }

            function animate()
            {
                resizeCanvas();
                render();
                requestAnimationFrame(animate);
            }

            function render()
            {
                if (!renderProgram) return;
                parameters.time = new Date().getTime() - parameters.start_time;
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                // First Draw Call: Compute Height Field
                gl.useProgram(heightProgram);              
                gl.bindFramebuffer(gl.FRAMEBUFFER, heightFrameBuffer);

                gl.viewport(0, 0, heightFrameBuffer.width, heightFrameBuffer.height);
                gl.uniform1f(heightUniforms.timeLocation, parameters.time / 1000);
                gl.uniform2f(heightUniforms.resolutionLocation, heightFrameBuffer.width, heightFrameBuffer.height);

                gl.bindBuffer(gl.ARRAY_BUFFER, buffer); 
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disableVertexAttribArray(vertex_position);

                gl.bindFramebuffer(gl.FRAMEBUFFER, null);

                // Second Draw Call: Render
                gl.useProgram(renderProgram);

                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, heightTexture);
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, wallTexture);
                
                gl.viewport(0, 0, parameters.screenWidth, parameters.screenHeight);

                // Set values to program variables
                gl.uniform1f(renderUniforms.timeLocation, parameters.time / 1000);
                gl.uniform2f(renderUniforms.resolutionLocation, parameters.screenWidth, parameters.screenHeight);
                gl.uniform1i(renderUniforms.heightSamplerLocation, 0);
                gl.uniform1i(renderUniforms.wallSamplerLocation, 1);
                gl.uniform3f(renderUniforms.eyeCoordinate, eyeCoordinate.radius, eyeCoordinate.phi, eyeCoordinate.theta);

                // Render geometry
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.vertexAttribPointer(vertex_position, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(vertex_position);
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                gl.disableVertexAttribArray(vertex_position);
            }

    </script>
</body>
</html>