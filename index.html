<!DOCTYPE HTML>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>Shallow Water</title>

		<style>
			html, body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas></canvas>
		<div id="info"></div>

		<script id="vs" type="x-shader/vertex">
			attribute vec3 position;

			void main() {

				gl_Position = vec4( position, 1.0 );

			}
		</script>

		<script id="fs" type="x-shader/fragment">
			#define EPS 0.01
			#define STEPSIZE 0.01
			#define MAXSTEPS 1000
			#define FREQ 10.0
			#define AMP 0.05
			#define OVERSTEP 4.0
			#define IOR 1.33

			uniform float time;
			uniform vec2 resolution;

			vec3 light1 = vec3(2.0, 2.0, 2.0);
			vec3 light2 = vec3(-2.0, 2.0, -2.0);
			vec3 light3 = vec3(0.0, 1.0, 0.0);

			float distBox(vec3 p)
			{
				vec3 b = vec3(1.0, 1.0, 1.0);
				vec3 d = abs(p) - b;
				return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));
			}

			float height(float x, float z)
			{
				float t = x * x * sin(time) + z * z * cos(time);
				return AMP * exp(-t) * cos(FREQ * t);
			}

			float height(vec3 p)
			{
				return height(p.x, p.z);
			}

			float frac(float x)
			{
				return x - floor(x);
			}

			vec3 getBoxNormal(vec3 p)
			{
				vec3 n = vec3((distBox(p+vec3(EPS,0,0))-distBox(p)),
							  (distBox(p+vec3(0,EPS,0))-distBox(p)),
							  (distBox(p+vec3(0,0,EPS))-distBox(p)));
				return normalize(n);
			}

			vec3 getSurfaceNormal(vec3 p)
			{
				vec3 n = vec3(height(p.x - EPS, p.z) - height(p.x + EPS, p.z),
							  2.0 * EPS,
							  height(p.x, p.z - EPS) - height(p.x, p.z + EPS));
				return normalize(n);
			}

			vec4 getWallColor(vec3 p)
			{
				 float x = floor((p.x + 1.0) * 0.5 * 20.0);
				 float y = floor((p.y + 1.0) * 0.5 * 20.0);
				 float z = floor((p.z + 1.0) * 0.5 * 20.0);
				 bool isSame = (frac(x * 0.5) < EPS) == (frac(z * 0.5) < EPS);
				 isSame = (frac(y * 0.5) < EPS) ? isSame : !isSame;
				 return isSame ? vec4(0.0, 0.6, 0.9, 1.0) : vec4(0.1);
			}

			vec3 reflection(vec3 v, vec3 n)
			{
				return -v + 2.0 * dot(v, n) * n;
			}

			float intensity(vec3 eye, vec3 p, vec3 n,
							float kSpec, float specWeight, float diffWeight)
			{
				vec3 toLight = normalize(light1 - p);
				vec3 toEye = normalize(eye - p);
				vec3 ref = normalize(reflection(toLight, n));

				float diffuse = 0.0;
				float specular = 0.0;

				// Do diffuse lighting
				diffuse +=  max(0.0, dot(toLight, n));
				// Do specular lighting
				specular += max(0.0, pow(dot(ref, toEye), kSpec));

				// Recompute for second light
				toLight = normalize(light2 - p);
				ref = normalize(reflection(toLight, n));
				diffuse += max(0.0, dot(toLight, ref));
				specular += max(0.0, pow(dot(ref, toEye), kSpec));

				// Recompute for third light
				toLight = normalize(light3 - p);
				ref = normalize(reflection(toLight, n));
				diffuse += max(0.0, dot(toLight, ref));
				specular += max(0.0, pow(dot(ref, toEye), kSpec));

				return specWeight * specular + diffWeight * diffuse;
			}

			vec4 shadeWall(vec3 eye, vec3 p, vec3 normal)
			{
				return intensity(eye, p, normal, 0.0, 0.0, 1.0) * getWallColor(p);
			}

			vec4 shadeWater(vec3 eye, vec3 p, vec3 normal)
			{
				return intensity(eye, p, normal, 15.0, 2.5, 0.0) * vec4(1.0);
			}

			void main()
			{
				vec3 eye = 3.0 * vec3(1.0);
				vec3 focus = vec3(0, 0, 0);
				vec3 forward = normalize(focus - eye);
				vec3 right = cross(forward, vec3(0.0, 1.0, 0.0));
				vec3 up = normalize(cross(right, forward));

				float f = 2.0;
				float u = gl_FragCoord.x * 2.0 / resolution.x - 1.0;
				float v = gl_FragCoord.y * 2.0 / resolution.y - 1.0;

				float ar = resolution.x / resolution.y;
				right *= ar;

				vec3 imagePos = eye + right * u + up * v + forward * f;
				vec3 dir = normalize(imagePos - eye);

				vec4 surfaceColor = vec4(0.0);
				vec4 boxColor = vec4(0.0);

				bool hitBox = false;
				bool hitSurface = false;

				// Ray march until we hit the bounding box
				vec3 p = eye;
				for (int i = 0; i < 50; i++) {
					float d = distBox(p);
					if(d < EPS)
					{
						hitBox = true;
						break;
					}
					p += dir * d;
				}

				// If we miss the box we just color in a black background
				if (!hitBox)
				{
					gl_FragColor = vec4(0.0);
					return;
				}

				// If the part we hit is below the surface
				if (p.y < height(p))
				{
					surfaceColor = shadeWater(eye, p, getBoxNormal(p));
					hitSurface = true;
				}
				// If the part we hit is above the surface
				else
				{
					for (int i = 0; i < MAXSTEPS; i++)
					{
						// When we hit very close to the surface
						if (p.y < height(p))
						{
							hitSurface = true;
							surfaceColor = shadeWater(eye, p, getSurfaceNormal(p));
							break;
						}

						// Checks if the ray hits the box from the inside
						float d = distBox(p);
						if (d >= EPS)
						{
							gl_FragColor = vec4(0.0);
							return;
						}

						p += dir * STEPSIZE;
					}
				}

				// Step out of the box and step backwards until we hit it
				p += OVERSTEP * dir;
				for (int i = 0; i < MAXSTEPS; i++)
				{
					float d = distBox(p);
					if (d < EPS)
					{
						break;
					}
					p -= dir * d;
				}

				vec4 wallColor = shadeWall(eye, p, -getBoxNormal(p));
				gl_FragColor = 0.3 * surfaceColor + 0.5 * wallColor;
			}
		</script>

		<script>
			window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

				return  window.webkitRequestAnimationFrame ||
				        window.mozRequestAnimationFrame ||
				        window.oRequestAnimationFrame ||
				        window.msRequestAnimationFrame ||
				        function(  callback, element ) {
					        window.setTimeout( callback, 1000 / 60 );
				        };

			})();


			var canvas,
			    gl,
			    buffer,
			    vertex_shader, fragment_shader,
			    currentProgram,
			    vertex_position,
			    timeLocation,
			    resolutionLocation,
			    parameters = {  start_time  : new Date().getTime(),
			                    time        : 0,
			                    screenWidth : 0,
			                    screenHeight: 0 };

			//load();
			init();
			animate();

			function read(textfile, id, type) {
				return new Promise((resolve, reject) => {
					var request = new XMLHttpRequest();
					request.open('GET', textfile, true);
					request.onload = () => resolve((id, type) => this.show);
					request.onerror = () => reject(request.statusText);
					request.send()
				})
			}

			function show(id, type){
				var script=document.createElement('script')
				script.id = id
				script.type = type
				script.textContent=this.response;
				document.body.appendChild(script)
			}

			function load() {
				vs_promise = read('vertex.shader', 'vs', "x-shader/vertex").then(() => {
					fs_promise = read('heightfield.frag', 'fs', "x-shader/fragment").then(() => {
						init()
					})
				})
			}

			function init() {

				// vertex_shader = read('file.sh');
				vertex_shader = document.getElementById('vs').textContent;
				//obj = document.getElementById('fs');
				fragment_shader = document.getElementById('fs').textContent;

				canvas = document.querySelector( 'canvas' );

				// Initialise WebGL

				try {

					gl = canvas.getContext( 'experimental-webgl' );

				} catch( error ) { }

				if ( !gl ) {

					throw "cannot create webgl context";

				}

				// Create Vertex buffer (2 triangles)

				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );

				// Create Program

				currentProgram = createProgram( vertex_shader, fragment_shader );

				timeLocation = gl.getUniformLocation( currentProgram, 'time' );
				resolutionLocation = gl.getUniformLocation( currentProgram, 'resolution' );

			}

			function createProgram( vertex, fragment ) {

				var program = gl.createProgram();

				var vs = createShader( vertex, gl.VERTEX_SHADER );
				var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );

				if ( vs == null || fs == null ) return null;

				gl.attachShader( program, vs );
				gl.attachShader( program, fs );

				gl.deleteShader( vs );
				gl.deleteShader( fs );

				gl.linkProgram( program );

				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {

					alert( "ERROR:\n" +
					"VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"ERROR: " + gl.getError() + "\n\n" +
					"- Vertex Shader -\n" + vertex + "\n\n" +
					"- Fragment Shader -\n" + fragment );

					return null;

				}

				return program;

			}

			function createShader( src, type ) {

				var shader = gl.createShader( type );

				gl.shaderSource( shader, src );
				gl.compileShader( shader );

				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {

					alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
					return null;

				}

				return shader;

			}

			function resizeCanvas( event ) {

				if ( canvas.width != canvas.clientWidth ||
					 canvas.height != canvas.clientHeight ) {

					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;

					parameters.screenWidth = canvas.width;
					parameters.screenHeight = canvas.height;

					gl.viewport( 0, 0, canvas.width, canvas.height );

				}

			}

			function animate() {

				resizeCanvas();
				render();
				requestAnimationFrame( animate );

			}

			function render() {

				if ( !currentProgram ) return;

				parameters.time = new Date().getTime() - parameters.start_time;

				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );

				// Load program into GPU

				gl.useProgram( currentProgram );

				// Set values to program variables

				gl.uniform1f( timeLocation, parameters.time / 1000 );
				gl.uniform2f( resolutionLocation, parameters.screenWidth, parameters.screenHeight );

				// Render geometry

				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );

			}

		</script>

	</body>
</html>
