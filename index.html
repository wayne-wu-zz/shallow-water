<!DOCTYPE HTML> 
<html> 
	<head> 
		<meta charset="utf-8"> 
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>Shallow Water</title> 
		
		<style> 
			html, body {
				background-color: #000000;
				margin: 0px;
				overflow: hidden;
				width: 100%;
				height: 100%;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style> 
	</head> 
	<body> 
 
		<canvas></canvas>
		<div id="info"></div> 
 
		<script id="vs" type="x-shader/vertex"> 
 
			attribute vec3 position;
 
			void main() {
 
				gl_Position = vec4( position, 1.0 );
 
			}
 
		</script> 
 
		<script id="fs" type="x-shader/fragment">
			#define EPS 0.00001
			#define STEPSIZE 0.001
			#define MAXSTEPS 10000
			#define FREQ 10.0
			#define AMP 0.1

			uniform float time;
			uniform vec2 resolution;
			
			float distBox( vec3 p )
			{
			  	return length(max(abs(p)-vec3(1.0),0.0));
			}

			float height( float x, float z ){
				float t = x*x + z*z;
				return AMP*exp(-t)*cos(FREQ*t);
			}

			float height( vec3 p ){
				return height(p.x, p.z);
			}

			vec3 getNormal( vec3 p )
			{
				float eps = 0.01;
				vec3 n = vec3(	height(p.x-eps,p.z) - height(p.x+eps,p.z),
								2.0*eps,
								height(p.x,p.z-eps) - height(p.x,p.z+eps));
				return normalize( n );
			}
			
			vec4 shade( vec3 p ){
				vec3 normal = getNormal(p);
				vec3 light1 = vec3(1.0, 2.0, 0.0);
				vec3 light2 = vec3(-1.0, 2.0, 0.0); 
				float intensity = max(0.0,dot(normalize(light1-p), normal));
				intensity += max(0.0,dot(normalize(light2-p), normal));
				return intensity * vec4(0.5);
			}
			
			void main( void ) {
				vec3 eye = (5.0 + sin(time)) * vec3(0.0,1.0,1.0);
				vec3 right = vec3(1,0,0);
				vec3 focus = vec3(0,0,0);
				vec3 forward = normalize(focus - eye);
				vec3 up = normalize(cross(right, forward)); 

				float f = 2.0;
				float u = gl_FragCoord.x * 2.0 / resolution.x - 1.0;
				float v = gl_FragCoord.y * 2.0 / resolution.y - 1.0;
					
				float ar = resolution.x/resolution.y;
				right *= ar;
				
				vec3 imagePos = eye + right * u + up * v + forward * f;
				vec3 dir = normalize(imagePos - eye);
				
				vec4 color = vec4(0.0);
				vec4 boxColor = vec4(0.0);

				float t = 0.0;

				vec3 p = eye + dir * t;
				bool hitbox = false;
				for (int i = 0; i < 50; ++i) {
					float d = distBox(p);
					if(d < 0.0001) 
					{
						boxColor = vec4(1.0,0.0,0.0,1.0);
						hitbox = true;
						break;
					}
					t += d;
					p = eye + dir * t;
				}

				if (!hitbox || height(p)>p.y){
					gl_FragColor = vec4(0.0);
					return;
				}

				for (int i = 0; i < MAXSTEPS; ++i) {
					if (min(p.x, p.z)<-1.0 || p.x > 1.0)
					{
						color = vec4(0.0);
						break;
					}
					if (p.y < height(p)){
						color = shade(p);
						break;
					}
					t += STEPSIZE;
					p = eye + dir * t;
				}

				gl_FragColor = color+0.1*boxColor;
			}
		</script> 
 
		<script> 
			window.requestAnimationFrame = window.requestAnimationFrame || ( function() {

				return  window.webkitRequestAnimationFrame ||
				        window.mozRequestAnimationFrame ||
				        window.oRequestAnimationFrame ||
				        window.msRequestAnimationFrame ||
				        function(  callback, element ) {
					        window.setTimeout( callback, 1000 / 60 );
				        };

			})();

 
			var canvas, 
			    gl, 
			    buffer, 
			    vertex_shader, fragment_shader, 
			    currentProgram,
			    vertex_position,
			    timeLocation,
			    resolutionLocation,
			    parameters = {  start_time  : new Date().getTime(), 
			                    time        : 0, 
			                    screenWidth : 0, 
			                    screenHeight: 0 };
 
			init();
			animate();
 
			function init() {
 
				vertex_shader = document.getElementById('vs').textContent;
				obj = document.getElementById('fs');
				fragment_shader = document.getElementById('fs').textContent;
 

 
				canvas = document.querySelector( 'canvas' );

 
				// Initialise WebGL
 
				try {
 
					gl = canvas.getContext( 'experimental-webgl' );
 
				} catch( error ) { }
 
				if ( !gl ) {
 
					throw "cannot create webgl context";
 
				}
 
				// Create Vertex buffer (2 triangles)
 
				buffer = gl.createBuffer();
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.bufferData( gl.ARRAY_BUFFER, new Float32Array( [ - 1.0, - 1.0, 1.0, - 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0, 1.0, - 1.0, 1.0 ] ), gl.STATIC_DRAW );
 
				// Create Program
 
				currentProgram = createProgram( vertex_shader, fragment_shader );

				timeLocation = gl.getUniformLocation( currentProgram, 'time' );
				resolutionLocation = gl.getUniformLocation( currentProgram, 'resolution' );
 
			}
 
			function createProgram( vertex, fragment ) {
 
				var program = gl.createProgram();
 
				var vs = createShader( vertex, gl.VERTEX_SHADER );
				var fs = createShader( '#ifdef GL_ES\nprecision highp float;\n#endif\n\n' + fragment, gl.FRAGMENT_SHADER );
 
				if ( vs == null || fs == null ) return null;
 
				gl.attachShader( program, vs );
				gl.attachShader( program, fs );
 
				gl.deleteShader( vs );
				gl.deleteShader( fs );
 
				gl.linkProgram( program );
 
				if ( !gl.getProgramParameter( program, gl.LINK_STATUS ) ) {
 
					alert( "ERROR:\n" +
					"VALIDATE_STATUS: " + gl.getProgramParameter( program, gl.VALIDATE_STATUS ) + "\n" +
					"ERROR: " + gl.getError() + "\n\n" +
					"- Vertex Shader -\n" + vertex + "\n\n" +
					"- Fragment Shader -\n" + fragment );
 
					return null;
 
				}
 
				return program;
 
			}
 
			function createShader( src, type ) {
 
				var shader = gl.createShader( type );
 
				gl.shaderSource( shader, src );
				gl.compileShader( shader );
 
				if ( !gl.getShaderParameter( shader, gl.COMPILE_STATUS ) ) {
 
					alert( ( type == gl.VERTEX_SHADER ? "VERTEX" : "FRAGMENT" ) + " SHADER:\n" + gl.getShaderInfoLog( shader ) );
					return null;
 
				}
 
				return shader;
 
			}
 
			function resizeCanvas( event ) {
 
				if ( canvas.width != canvas.clientWidth ||
					 canvas.height != canvas.clientHeight ) {

					canvas.width = canvas.clientWidth;
					canvas.height = canvas.clientHeight;

					parameters.screenWidth = canvas.width;
					parameters.screenHeight = canvas.height;

					gl.viewport( 0, 0, canvas.width, canvas.height );

				}
 
			}
 
			function animate() {
 
				resizeCanvas();
				render();
				requestAnimationFrame( animate );
 
			}
 
			function render() {
 
				if ( !currentProgram ) return;
 
				parameters.time = new Date().getTime() - parameters.start_time;
 
				gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT );
 
				// Load program into GPU
 
				gl.useProgram( currentProgram );
 
				// Set values to program variables
 
				gl.uniform1f( timeLocation, parameters.time / 1000 );
				gl.uniform2f( resolutionLocation, parameters.screenWidth, parameters.screenHeight );
 
				// Render geometry
 
				gl.bindBuffer( gl.ARRAY_BUFFER, buffer );
				gl.vertexAttribPointer( vertex_position, 2, gl.FLOAT, false, 0, 0 );
				gl.enableVertexAttribArray( vertex_position );
				gl.drawArrays( gl.TRIANGLES, 0, 6 );
				gl.disableVertexAttribArray( vertex_position );
 
			}
 
		</script> 
 
	</body> 
</html>